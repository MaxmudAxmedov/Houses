import {
  __commonJS
} from "./chunk-UV5CTPV7.js";

// node_modules/redux-persist/dist/redux-persist.js
var require_redux_persist = __commonJS({
  "node_modules/redux-persist/dist/redux-persist.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.ReduxPersist = {});
    })(exports, function(exports2) {
      "use strict";
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(source, true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(source).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function _objectWithoutProperties(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose(source, excluded);
        var key, i;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        }
      }
      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
          return Array.from(iter);
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      var KEY_PREFIX = "persist:";
      var FLUSH = "persist/FLUSH";
      var REHYDRATE = "persist/REHYDRATE";
      var PAUSE = "persist/PAUSE";
      var PERSIST = "persist/PERSIST";
      var PURGE = "persist/PURGE";
      var REGISTER = "persist/REGISTER";
      var DEFAULT_VERSION = -1;
      function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
        var debug = _ref.debug;
        var newState = _objectSpread2({}, reducedState);
        if (inboundState && _typeof(inboundState) === "object") {
          Object.keys(inboundState).forEach(function(key) {
            if (key === "_persist")
              return;
            if (originalState[key] !== reducedState[key]) {
              if (debug)
                console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
              return;
            }
            newState[key] = inboundState[key];
          });
        }
        if (debug && inboundState && _typeof(inboundState) === "object")
          console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(", "), "'"));
        return newState;
      }
      function createPersistoid(config) {
        var blacklist = config.blacklist || null;
        var whitelist = config.whitelist || null;
        var transforms = config.transforms || [];
        var throttle = config.throttle || 0;
        var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
        var storage = config.storage;
        var serialize;
        if (config.serialize === false) {
          serialize = function serialize2(x) {
            return x;
          };
        } else if (typeof config.serialize === "function") {
          serialize = config.serialize;
        } else {
          serialize = defaultSerialize;
        }
        var writeFailHandler = config.writeFailHandler || null;
        var lastState = {};
        var stagedState = {};
        var keysToProcess = [];
        var timeIterator = null;
        var writePromise = null;
        var update = function update2(state) {
          Object.keys(state).forEach(function(key) {
            if (!passWhitelistBlacklist(key))
              return;
            if (lastState[key] === state[key])
              return;
            if (keysToProcess.indexOf(key) !== -1)
              return;
            keysToProcess.push(key);
          });
          Object.keys(lastState).forEach(function(key) {
            if (state[key] === void 0 && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== void 0) {
              keysToProcess.push(key);
            }
          });
          if (timeIterator === null) {
            timeIterator = setInterval(processNextKey, throttle);
          }
          lastState = state;
        };
        function processNextKey() {
          if (keysToProcess.length === 0) {
            if (timeIterator)
              clearInterval(timeIterator);
            timeIterator = null;
            return;
          }
          var key = keysToProcess.shift();
          var endState = transforms.reduce(function(subState, transformer) {
            return transformer.in(subState, key, lastState);
          }, lastState[key]);
          if (endState !== void 0) {
            try {
              stagedState[key] = serialize(endState);
            } catch (err) {
              console.error("redux-persist/createPersistoid: error serializing state", err);
            }
          } else {
            delete stagedState[key];
          }
          if (keysToProcess.length === 0) {
            writeStagedState();
          }
        }
        function writeStagedState() {
          Object.keys(stagedState).forEach(function(key) {
            if (lastState[key] === void 0) {
              delete stagedState[key];
            }
          });
          writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
        }
        function passWhitelistBlacklist(key) {
          if (whitelist && whitelist.indexOf(key) === -1 && key !== "_persist")
            return false;
          if (blacklist && blacklist.indexOf(key) !== -1)
            return false;
          return true;
        }
        function onWriteFail(err) {
          if (writeFailHandler)
            writeFailHandler(err);
          if (err && true) {
            console.error("Error storing data", err);
          }
        }
        var flush = function flush2() {
          while (keysToProcess.length !== 0) {
            processNextKey();
          }
          return writePromise || Promise.resolve();
        };
        return {
          update,
          flush
        };
      }
      function defaultSerialize(data) {
        return JSON.stringify(data);
      }
      function getStoredState(config) {
        var transforms = config.transforms || [];
        var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
        var storage = config.storage;
        var debug = config.debug;
        var deserialize;
        if (config.deserialize === false) {
          deserialize = function deserialize2(x) {
            return x;
          };
        } else if (typeof config.deserialize === "function") {
          deserialize = config.deserialize;
        } else {
          deserialize = defaultDeserialize;
        }
        return storage.getItem(storageKey).then(function(serialized) {
          if (!serialized)
            return void 0;
          else {
            try {
              var state = {};
              var rawState = deserialize(serialized);
              Object.keys(rawState).forEach(function(key) {
                state[key] = transforms.reduceRight(function(subState, transformer) {
                  return transformer.out(subState, key, rawState);
                }, deserialize(rawState[key]));
              });
              return state;
            } catch (err) {
              if (debug)
                console.log("redux-persist/getStoredState: Error restoring data ".concat(serialized), err);
              throw err;
            }
          }
        });
      }
      function defaultDeserialize(serial) {
        return JSON.parse(serial);
      }
      function purgeStoredState(config) {
        var storage = config.storage;
        var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
        return storage.removeItem(storageKey, warnIfRemoveError);
      }
      function warnIfRemoveError(err) {
        if (err && true) {
          console.error("redux-persist/purgeStoredState: Error purging data stored state", err);
        }
      }
      var DEFAULT_TIMEOUT = 5e3;
      function persistReducer(config, baseReducer) {
        {
          if (!config)
            throw new Error("config is required for persistReducer");
          if (!config.key)
            throw new Error("key is required in persistor config");
          if (!config.storage)
            throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
        }
        var version = config.version !== void 0 ? config.version : DEFAULT_VERSION;
        var debug = config.debug || false;
        var stateReconciler = config.stateReconciler === void 0 ? autoMergeLevel1 : config.stateReconciler;
        var getStoredState$$1 = config.getStoredState || getStoredState;
        var timeout = config.timeout !== void 0 ? config.timeout : DEFAULT_TIMEOUT;
        var _persistoid = null;
        var _purge = false;
        var _paused = true;
        var conditionalUpdate = function conditionalUpdate2(state) {
          state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
          return state;
        };
        return function(state, action) {
          var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties(_ref, ["_persist"]);
          var restState = rest;
          if (action.type === PERSIST) {
            var _sealed = false;
            var _rehydrate = function _rehydrate2(payload, err) {
              if (_sealed)
                console.error('redux-persist: rehydrate for "'.concat(config.key, '" called after timeout.'), payload, err);
              if (!_sealed) {
                action.rehydrate(config.key, payload, err);
                _sealed = true;
              }
            };
            timeout && setTimeout(function() {
              !_sealed && _rehydrate(void 0, new Error('redux-persist: persist timed out for persist key "'.concat(config.key, '"')));
            }, timeout);
            _paused = false;
            if (!_persistoid)
              _persistoid = createPersistoid(config);
            if (_persist) {
              return _objectSpread2({}, baseReducer(restState, action), {
                _persist
              });
            }
            if (typeof action.rehydrate !== "function" || typeof action.register !== "function")
              throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
            action.register(config.key);
            getStoredState$$1(config).then(function(restoredState) {
              var migrate = config.migrate || function(s, v) {
                return Promise.resolve(s);
              };
              migrate(restoredState, version).then(function(migratedState) {
                _rehydrate(migratedState);
              }, function(migrateErr) {
                if (migrateErr)
                  console.error("redux-persist: migration error", migrateErr);
                _rehydrate(void 0, migrateErr);
              });
            }, function(err) {
              _rehydrate(void 0, err);
            });
            return _objectSpread2({}, baseReducer(restState, action), {
              _persist: {
                version,
                rehydrated: false
              }
            });
          } else if (action.type === PURGE) {
            _purge = true;
            action.result(purgeStoredState(config));
            return _objectSpread2({}, baseReducer(restState, action), {
              _persist
            });
          } else if (action.type === FLUSH) {
            action.result(_persistoid && _persistoid.flush());
            return _objectSpread2({}, baseReducer(restState, action), {
              _persist
            });
          } else if (action.type === PAUSE) {
            _paused = true;
          } else if (action.type === REHYDRATE) {
            if (_purge)
              return _objectSpread2({}, restState, {
                _persist: _objectSpread2({}, _persist, {
                  rehydrated: true
                })
                // @NOTE if key does not match, will continue to default else below
              });
            if (action.key === config.key) {
              var reducedState = baseReducer(restState, action);
              var inboundState = action.payload;
              var reconciledRest = stateReconciler !== false && inboundState !== void 0 ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
              var _newState = _objectSpread2({}, reconciledRest, {
                _persist: _objectSpread2({}, _persist, {
                  rehydrated: true
                })
              });
              return conditionalUpdate(_newState);
            }
          }
          if (!_persist)
            return baseReducer(state, action);
          var newState = baseReducer(restState, action);
          if (newState === restState)
            return state;
          return conditionalUpdate(_objectSpread2({}, newState, {
            _persist
          }));
        };
      }
      function symbolObservablePonyfill(root2) {
        var result2;
        var Symbol2 = root2.Symbol;
        if (typeof Symbol2 === "function") {
          if (Symbol2.observable) {
            result2 = Symbol2.observable;
          } else {
            result2 = Symbol2("observable");
            Symbol2.observable = result2;
          }
        } else {
          result2 = "@@observable";
        }
        return result2;
      }
      var root;
      if (typeof self !== "undefined") {
        root = self;
      } else if (typeof window !== "undefined") {
        root = window;
      } else if (typeof global !== "undefined") {
        root = global;
      } else if (typeof module !== "undefined") {
        root = module;
      } else {
        root = Function("return this")();
      }
      var result = symbolObservablePonyfill(root);
      var randomString = function randomString2() {
        return Math.random().toString(36).substring(7).split("").join(".");
      };
      var ActionTypes = {
        INIT: "@@redux/INIT" + randomString(),
        REPLACE: "@@redux/REPLACE" + randomString(),
        PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
          return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
        }
      };
      function isPlainObject(obj) {
        if (typeof obj !== "object" || obj === null)
          return false;
        var proto = obj;
        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(obj) === proto;
      }
      function createStore(reducer, preloadedState, enhancer) {
        var _ref2;
        if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
          throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function.");
        }
        if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
          enhancer = preloadedState;
          preloadedState = void 0;
        }
        if (typeof enhancer !== "undefined") {
          if (typeof enhancer !== "function") {
            throw new Error("Expected the enhancer to be a function.");
          }
          return enhancer(createStore)(reducer, preloadedState);
        }
        if (typeof reducer !== "function") {
          throw new Error("Expected the reducer to be a function.");
        }
        var currentReducer = reducer;
        var currentState = preloadedState;
        var currentListeners = [];
        var nextListeners = currentListeners;
        var isDispatching = false;
        function ensureCanMutateNextListeners() {
          if (nextListeners === currentListeners) {
            nextListeners = currentListeners.slice();
          }
        }
        function getState() {
          if (isDispatching) {
            throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
          }
          return currentState;
        }
        function subscribe(listener) {
          if (typeof listener !== "function") {
            throw new Error("Expected the listener to be a function.");
          }
          if (isDispatching) {
            throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api-reference/store#subscribe(listener) for more details.");
          }
          var isSubscribed = true;
          ensureCanMutateNextListeners();
          nextListeners.push(listener);
          return function unsubscribe() {
            if (!isSubscribed) {
              return;
            }
            if (isDispatching) {
              throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api-reference/store#subscribe(listener) for more details.");
            }
            isSubscribed = false;
            ensureCanMutateNextListeners();
            var index = nextListeners.indexOf(listener);
            nextListeners.splice(index, 1);
          };
        }
        function dispatch(action) {
          if (!isPlainObject(action)) {
            throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
          }
          if (typeof action.type === "undefined") {
            throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
          }
          if (isDispatching) {
            throw new Error("Reducers may not dispatch actions.");
          }
          try {
            isDispatching = true;
            currentState = currentReducer(currentState, action);
          } finally {
            isDispatching = false;
          }
          var listeners = currentListeners = nextListeners;
          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            listener();
          }
          return action;
        }
        function replaceReducer(nextReducer) {
          if (typeof nextReducer !== "function") {
            throw new Error("Expected the nextReducer to be a function.");
          }
          currentReducer = nextReducer;
          dispatch({
            type: ActionTypes.REPLACE
          });
        }
        function observable() {
          var _ref;
          var outerSubscribe = subscribe;
          return _ref = {
            /**
             * The minimal observable subscription method.
             * @param {Object} observer Any object that can be used as an observer.
             * The observer object should have a `next` method.
             * @returns {subscription} An object with an `unsubscribe` method that can
             * be used to unsubscribe the observable from the store, and prevent further
             * emission of values from the observable.
             */
            subscribe: function subscribe2(observer) {
              if (typeof observer !== "object" || observer === null) {
                throw new TypeError("Expected the observer to be an object.");
              }
              function observeState() {
                if (observer.next) {
                  observer.next(getState());
                }
              }
              observeState();
              var unsubscribe = outerSubscribe(observeState);
              return {
                unsubscribe
              };
            }
          }, _ref[result] = function() {
            return this;
          }, _ref;
        }
        dispatch({
          type: ActionTypes.INIT
        });
        return _ref2 = {
          dispatch,
          subscribe,
          getState,
          replaceReducer
        }, _ref2[result] = observable, _ref2;
      }
      function warning(message) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
      function getUndefinedStateErrorMessage(key, action) {
        var actionType = action && action.type;
        var actionDescription = actionType && 'action "' + String(actionType) + '"' || "an action";
        return "Given " + actionDescription + ', reducer "' + key + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.';
      }
      function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
        var reducerKeys = Object.keys(reducers);
        var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
        if (reducerKeys.length === 0) {
          return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
        }
        if (!isPlainObject(inputState)) {
          return "The " + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
        }
        var unexpectedKeys = Object.keys(inputState).filter(function(key) {
          return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
        });
        unexpectedKeys.forEach(function(key) {
          unexpectedKeyCache[key] = true;
        });
        if (action && action.type === ActionTypes.REPLACE)
          return;
        if (unexpectedKeys.length > 0) {
          return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
        }
      }
      function assertReducerShape(reducers) {
        Object.keys(reducers).forEach(function(key) {
          var reducer = reducers[key];
          var initialState2 = reducer(void 0, {
            type: ActionTypes.INIT
          });
          if (typeof initialState2 === "undefined") {
            throw new Error('Reducer "' + key + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
          }
          if (typeof reducer(void 0, {
            type: ActionTypes.PROBE_UNKNOWN_ACTION()
          }) === "undefined") {
            throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle " + ActionTypes.INIT + ' or other actions in "redux/*" ') + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
          }
        });
      }
      function combineReducers(reducers) {
        var reducerKeys = Object.keys(reducers);
        var finalReducers = {};
        for (var i = 0; i < reducerKeys.length; i++) {
          var key = reducerKeys[i];
          {
            if (typeof reducers[key] === "undefined") {
              warning('No reducer provided for key "' + key + '"');
            }
          }
          if (typeof reducers[key] === "function") {
            finalReducers[key] = reducers[key];
          }
        }
        var finalReducerKeys = Object.keys(finalReducers);
        var unexpectedKeyCache;
        {
          unexpectedKeyCache = {};
        }
        var shapeAssertionError;
        try {
          assertReducerShape(finalReducers);
        } catch (e) {
          shapeAssertionError = e;
        }
        return function combination(state, action) {
          if (state === void 0) {
            state = {};
          }
          if (shapeAssertionError) {
            throw shapeAssertionError;
          }
          {
            var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
            if (warningMessage) {
              warning(warningMessage);
            }
          }
          var hasChanged = false;
          var nextState = {};
          for (var _i = 0; _i < finalReducerKeys.length; _i++) {
            var _key = finalReducerKeys[_i];
            var reducer = finalReducers[_key];
            var previousStateForKey = state[_key];
            var nextStateForKey = reducer(previousStateForKey, action);
            if (typeof nextStateForKey === "undefined") {
              var errorMessage = getUndefinedStateErrorMessage(_key, action);
              throw new Error(errorMessage);
            }
            nextState[_key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
          }
          return hasChanged ? nextState : state;
        };
      }
      function isCrushed() {
      }
      if (typeof isCrushed.name === "string" && isCrushed.name !== "isCrushed") {
        warning('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
      }
      function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {
        var debug = _ref.debug;
        var newState = _objectSpread2({}, reducedState);
        if (inboundState && _typeof(inboundState) === "object") {
          Object.keys(inboundState).forEach(function(key) {
            if (key === "_persist")
              return;
            if (originalState[key] !== reducedState[key]) {
              if (debug)
                console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
              return;
            }
            if (isPlainEnoughObject(reducedState[key])) {
              newState[key] = _objectSpread2({}, newState[key], {}, inboundState[key]);
              return;
            }
            newState[key] = inboundState[key];
          });
        }
        if (debug && inboundState && _typeof(inboundState) === "object")
          console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(", "), "'"));
        return newState;
      }
      function isPlainEnoughObject(o) {
        return o !== null && !Array.isArray(o) && _typeof(o) === "object";
      }
      function persistCombineReducers(config, reducers) {
        config.stateReconciler = config.stateReconciler === void 0 ? autoMergeLevel2 : config.stateReconciler;
        return persistReducer(config, combineReducers(reducers));
      }
      var initialState = {
        registry: [],
        bootstrapped: false
      };
      var persistorReducer = function persistorReducer2() {
        var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState;
        var action = arguments.length > 1 ? arguments[1] : void 0;
        switch (action.type) {
          case REGISTER:
            return _objectSpread2({}, state, {
              registry: [].concat(_toConsumableArray(state.registry), [action.key])
            });
          case REHYDRATE:
            var firstIndex = state.registry.indexOf(action.key);
            var registry = _toConsumableArray(state.registry);
            registry.splice(firstIndex, 1);
            return _objectSpread2({}, state, {
              registry,
              bootstrapped: registry.length === 0
            });
          default:
            return state;
        }
      };
      function persistStore(store, options, cb) {
        {
          var optionsToTest = options || {};
          var bannedKeys = ["blacklist", "whitelist", "transforms", "storage", "keyPrefix", "migrate"];
          bannedKeys.forEach(function(k) {
            if (!!optionsToTest[k])
              console.error('redux-persist: invalid option passed to persistStore: "'.concat(k, '". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.'));
          });
        }
        var boostrappedCb = cb || false;
        var _pStore = createStore(persistorReducer, initialState, options && options.enhancer ? options.enhancer : void 0);
        var register = function register2(key) {
          _pStore.dispatch({
            type: REGISTER,
            key
          });
        };
        var rehydrate = function rehydrate2(key, payload, err) {
          var rehydrateAction = {
            type: REHYDRATE,
            payload,
            err,
            key
            // dispatch to `store` to rehydrate and `persistor` to track result
          };
          store.dispatch(rehydrateAction);
          _pStore.dispatch(rehydrateAction);
          if (boostrappedCb && persistor.getState().bootstrapped) {
            boostrappedCb();
            boostrappedCb = false;
          }
        };
        var persistor = _objectSpread2({}, _pStore, {
          purge: function purge() {
            var results = [];
            store.dispatch({
              type: PURGE,
              result: function result2(purgeResult) {
                results.push(purgeResult);
              }
            });
            return Promise.all(results);
          },
          flush: function flush() {
            var results = [];
            store.dispatch({
              type: FLUSH,
              result: function result2(flushResult) {
                results.push(flushResult);
              }
            });
            return Promise.all(results);
          },
          pause: function pause() {
            store.dispatch({
              type: PAUSE
            });
          },
          persist: function persist() {
            store.dispatch({
              type: PERSIST,
              register,
              rehydrate
            });
          }
        });
        if (!(options && options.manualPersist)) {
          persistor.persist();
        }
        return persistor;
      }
      function createMigrate(migrations, config) {
        var _ref = config || {}, debug = _ref.debug;
        return function(state, currentVersion) {
          if (!state) {
            if (debug)
              console.log("redux-persist: no inbound state, skipping migration");
            return Promise.resolve(void 0);
          }
          var inboundVersion = state._persist && state._persist.version !== void 0 ? state._persist.version : DEFAULT_VERSION;
          if (inboundVersion === currentVersion) {
            if (debug)
              console.log("redux-persist: versions match, noop migration");
            return Promise.resolve(state);
          }
          if (inboundVersion > currentVersion) {
            console.error("redux-persist: downgrading version is not supported");
            return Promise.resolve(state);
          }
          var migrationKeys = Object.keys(migrations).map(function(ver) {
            return parseInt(ver);
          }).filter(function(key) {
            return currentVersion >= key && key > inboundVersion;
          }).sort(function(a, b) {
            return a - b;
          });
          if (debug)
            console.log("redux-persist: migrationKeys", migrationKeys);
          try {
            var migratedState = migrationKeys.reduce(function(state2, versionKey) {
              if (debug)
                console.log("redux-persist: running migration for versionKey", versionKey);
              return migrations[versionKey](state2);
            }, state);
            return Promise.resolve(migratedState);
          } catch (err) {
            return Promise.reject(err);
          }
        };
      }
      function createTransform(inbound, outbound) {
        var config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var whitelist = config.whitelist || null;
        var blacklist = config.blacklist || null;
        function whitelistBlacklistCheck(key) {
          if (whitelist && whitelist.indexOf(key) === -1)
            return true;
          if (blacklist && blacklist.indexOf(key) !== -1)
            return true;
          return false;
        }
        return {
          in: function _in(state, key, fullState) {
            return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state;
          },
          out: function out(state, key, fullState) {
            return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state;
          }
        };
      }
      exports2.persistReducer = persistReducer;
      exports2.persistCombineReducers = persistCombineReducers;
      exports2.persistStore = persistStore;
      exports2.createMigrate = createMigrate;
      exports2.createTransform = createTransform;
      exports2.getStoredState = getStoredState;
      exports2.createPersistoid = createPersistoid;
      exports2.purgeStoredState = purgeStoredState;
      exports2.KEY_PREFIX = KEY_PREFIX;
      exports2.FLUSH = FLUSH;
      exports2.REHYDRATE = REHYDRATE;
      exports2.PAUSE = PAUSE;
      exports2.PERSIST = PERSIST;
      exports2.PURGE = PURGE;
      exports2.REGISTER = REGISTER;
      exports2.DEFAULT_VERSION = DEFAULT_VERSION;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});
export default require_redux_persist();
//# sourceMappingURL=redux-persist_dist_redux-persist__js.js.map
